---
title: Attacking JWTs Using Burp Suite
date: 2025-07-06
categories: [Portswigger, DoD Cyber Sentinel]
tags: [jwt,web]     # TAG names should always be lowercase
---

My first encounter with JWTs was during the DoD Cyber Sentinel CTF. Despite being able to complete the challenge by referencing other writeups and stack overflow, there was still a lot of knowledge gap. The following weeks after the CTF, I did more research on JWTs and came across the Portswigger labs. Now that I have completed all the JWT labs on Portswigger, I have a much better understanding of them and I will share a detailed walkthrough exploiting the various JWT vulnerabilities using Burp Suite and explaining the concepts behind them.

## Overview
JSON Web Tokens (JWTs) are a standard method for securely transmitting JSON data between a server and a client. They consist of three components: the header, payload, and signature, each separated by a period (`.`). The header and payload are Base64URL-encoded JSON objects and can be easily decoded. They are typically used for authentication, session management, and access control mechanisms.

### Header

The header contains metadata about the token, including the token type (`"typ": "JWT"`) and the cryptographic algorithm (`"alg": "HS256"`) that was used to sign the token.

### Payload

The payload holds pieces of information about the user or the token. In the example below, the following claims are made after the client successfully authenticated to the website:

- `"user": "agent"` - the username of the authenticated user.
- `"role": "user"` - the user's assigned role and its associated privileges.
- `"iat": 1749925457` - the "issued at" timestamp in Unix time, indicating when the token was generated.
- `"exp": 1749929057` - the expiration timestamp in Unix time, after which the user must re-authenticate.

![img-description](/assets/decoded_example.png)
_Token from DoD Cyber Sentinel CTF decoded on JWT.io_

### Signature

The signature is the part of the token after the second period. It is generated by hashing the Base64URL-encoded header and payload using the specified algorithm and a secret signing key known only to the server. This process ensures the integrity and authenticity of the token. If the token is altered in any way, the signature will no longer match, and the token will be rejected by the server. The signing key can be a symmetric or asymmetric cryptographic algorithm.

### Issuing JWTs

There are two main ways the server sends JWTs to the client:
- HTTP-only Cookies: The server sends the JWT via a Set-Cookie header. The browser stores it and automatically includes it in future requests. This method is commonly used in traditional webapps.
![img-description](/assets/set_cookie.png)
_From Portswigger labs_

- Response Body: The server sends the JWT in the response body. The client (developer code) must manually store it and attach it to requests using the `Authorization: Bearer <JWT>` header. This method is commonly used with API requests and single page applications.
![img-description](/assets/body_response.png)
_From DoD Cyber Sentinel CTF_

### Benefits and Vulnerabilities

JWTs are stateless, meaning the web server does not retain any information about the content it has sent to the client and treats each interaction independently. The security of JWTs relies on the signing key remaining secret, and the server accepts or denies the client's requests by verifying the token’s signature. This statelessness is highly advantageous for scalability as the server does not need to store session information for every active user. Instead, it can quickly verify the validity of client requests using the token’s signature.

However, the flexibility that JWTs offer developers and the stateless nature can also introduce vulnerabilities. Improper implementations and misconfigurations surrounding the issuing and verification of the tokens can easily be exploited, allowing attackers to tamper with the tokens. The following sections will demonstrate how this is done using Burp Suite on the Portswigger labs.

## Setting Up Burp Suite

First thing you want to do is install the JWT Editor Extension from the BAppStore. This extension has features like highlighting requests that have JWTs and many more which will be showcased throughout.
![img-description](/assets/JWT_Editor.png)

## Portswigger Labs

There are four constants in the Portswigger labs, so I will mention them here once and the rest of the content will focus on the vulnerability and exploitation technique.

1. Identify the HTTP traffic where you successfully authenticate with the given credentials for the user `wiener`.
![img-description](/assets/highlight.png)

2. Send the request to Repeater and attempt to access the admin page by changing the GET request to `GET /admin`.

3. Switch to the JSON Web Token Tab and tamper with the token and take advantage of the misconfigurations to authenticate as the `administrator` user.

4. Once successfully authenticated as the administrator, delete a user's account by changing the GET request to `GET /admin/delete?username=carlos` and following the redirection.

## Unverified Signature

This is a rather simple vulnerability to bypass. Like I mentioned earlier, the whole security of JWTs relies on the verification of the signature. Once you  find a valid token, you can test for this vulnerability by simply changing the contents of the header and/or payload sections of the JWT. You would expect the server to reject this token since the signature is for the original content of the token and you can't resign the new claims since you don't know the secret key the server used to sign it.

In this case, changing the `"sub":` value from `wiener` to `administrator` would allow you to authenticate as the administrator and access the admin page despite the signature matching the original content of the JWT and not the tampered version.

![img-description](/assets/lab01.png)

## Flawed Verification

This vulnerability is caused when the client can tell the server what algorithm was used to sign the token and hence should be used to verify the token. This can be exploited by changing the `"alg":` parameter to `none` and removing the signature portion of the JWT. The server should reject this request but if misconfigured, it will go ahead and process whatever claim there is in the header and payload, without the signature present.

![img-description](/assets/alg_none.png)

This was also the vulnerability showcased in the DoD Cyber Sentinel CTF. Switching the role of the user to admin, changing the `"alg":` to none, removing the signature from the token, and attaching the tampered token with the `Authorization: Bearer <token>` schema allowed access to the secret directory with the flag in it. I was using JWT.io during the challenge to tamper the token since I didn't know about the Burp Suite extension.

![img-description](/assets/cyber_sent_tampered.png)
_Tampered token with signature removed_

![img-description](/assets/cyber_sent.png)
_Token attached to the request using Authorization: Bearer_

## Weak Signing Key

This vulnerability occurs when a weak symmetric encryption key is used to sign the token. When this happens, you can use various tools and wordlist to brute force the secret for the signing key.

First you will want to download or make a wordlist of potential/common JWT secrets.
```
wget https://raw.githubusercontent.com/wallarm/jwt-secrets/refs/heads/master/jwt.secrets.list
```
Once you have your token and wordlist you can brute force it on hashcat using the following command and the path to your wordlist.

```
hashcat -a 0 -m 16500 'eyJraWQiOiJkNDcxYmY0Ni1iNzhmLTQ1NGMtYmU0ZS05OGRmYzMzMTQxMzEiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTc1MTU3MDI2MCwic3ViIjoid2llbmVyIn0.besFW3CGpwPlLxYqc4WNI-BtVZAg686WDWmLvNHJr9k' /home/dag/portswigger/jwt/jwt.secrets.list
```
If a weak signing key was used, you will get an output similar to the one below. In this case (scroll all the way to the right on the code snippet) we can see that the secret is `secret1`.
```
eyJraWQiOiJkNDcxYmY0Ni1iNzhmLTQ1NGMtYmU0ZS05OGRmYzMzMTQxMzEiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTc1MTU3MDI2MCwic3ViIjoid2llbmVyIn0.besFW3CGpwPlLxYqc4WNI-BtVZAg686WDWmLvNHJr9k:secret1
                                                     
Session..........: hashcat
Status...........: Cracked
Hash.Mode........: 16500 (JWT (JSON Web Token))
Hash.Target......: eyJraWQiOiJkNDcxYmY0Ni1iNzhmLTQ1NGMtYmU0ZS05OGRmYzM...NHJr9k

```
Since we know the secret, we can recreate the signing key and tamper the token as we please and resign it so that its valid token.

To do this on Burp Suite:
1. Go to the JWT Editor tab and generate a new symmetric key
2. Change the `"k":` parameter to the Base64Url-encoding of the secret (`c2VjcmV0MQ==` for secret1 in this case).
![img-description](/assets/symetric_key.png)
3. Go back to the JSON Web Token tab on Repeater and change the content of the payload. Click `Sign` and choose the new key you just generated. Select the `Don't modify header option` so that the same header as the original token and the secret you brute forced is used to sign the token.
![img-description](/assets/resign.png)

## JWK Header Injection

JSON Web Key (JWK) is an optional parameter for the header when using asymmetric encryption to sign the token. This parameter allows the server to send its public key within the token. The vulnerability arises when the server doesn't check the source of the public key. An attacker could provide their own public key and sign the token with their private key. So, now the attacker is able to change the contents of the token and sign it with their private key, and the server uses the public key in the JWK parameter to verify it's legitimacy.

So to do this in Burp Suite:
1. Generate your own asymmetric key in JWK format.
![img-description](/assets/rsa.png)

2. Change the contents of the payload and click on Attack > Embedded JWK, and choose the asymmetric key you created.
![img-description](/assets/embed_jwk.png)

The server is not verifying if the public key came from a trusted source so it's processing it as it would for a valid token. The final JWT will contain your public key information in the JWK header and be signed using your private key.

![img-description](/assets/jwk_final.png)

## JKU Header Injection

JKU header injections follow the same concept as JWK injection. The difference is, instead of having the public key within the token, there is a URL telling the server where it can find it. To exploit this, you can copy the public key of your asymmetric key and store it on a different website. This website can store any number of keys so you would also need to change the `"kid":` value on the header to your key's id so the server knows to retrieve it. Then you would add the JKU parameter and tell it to fetch the public key from that website to use as verification of the signature.

![img-description](/assets/copy_jwk.png)
_Copy the public key as JWK stored on an external server_

![img-description](/assets/jku_final.png)
_JKU and kid parameters adjusted and signing with your private key_

## KID Header Path Traversal

The `"kid"` parameter tells there which key to use to verify the token. If the entry is not sanitized, an attacker can use directory traversal to point it to any file as the signing key. The `/dev/null` can be used on most linux based servers as its an empty file. If it uses symmetric encryption you can then sign your token with an "empty" key and it will have a matching secret.


1. Since you can't sign without a key using the JWT extension, you can make the secret a Base64 encoded null byte.
![img-description](/assets/null.png)


2. Change the `"kid":` parameter to point to the `/dev/null` file. Change the payload and sign it with a null byte key to have a valid token.
![img-description](/assets/kid.png)


## Algorithm Confusion

The core of the algorithm confusion summary is that it trusts whatever alg is in the token. If the server uses asymmetric encryption, you can use the public key to sign the JWT and tell the server to verify it using a symmetric algorithm. A misconfigured server then missaplies the public key and uses it as the secret key to verify the JWT.

To exploit this vulnerability:
1. Find the server public key. This can be found at the standard endpoint for this example.
![img-description](/assets/endpoint.png)
2. Create an RSA key using the server's public key.
![img-description](/assets/conf_rsa.png)
3. A little bit of guessing involved at this step. We're going to guess that the server is storing it as a PEM file. So, we will copy the RSA token as a PEM file and Base64 encode it.
![img-description](/assets/pem_encode.png)
4. Use the encoded PEM file as the secret for the symmetric algorithm key we create.
![img-description](/assets/conf_sym.png)
5. Make the changes to the payload and sign it with the key.
![img-description](/assets/conf_sign.png)

So to recap, by changing the algorithm to a symmetric algorithm, using the public key as the shared secret, and keeping the kid parameter of the original token, we "confuse" the server into using the public key as a symmetric key to verify the token.

## Algorithm Confusion without Exposed Key

If you can't find the public key on an exposed endpoint, this attack can still work. What you need to do is get two separate valid tokens. You can do this by logging in and logging out and logging back in.
1. Once you have your two tokens, you will use this tool to derive potential public keys and JWTs.
```
git clone https://github.com/silentsignal/rsa_sign2n.git
```
```
docker build . -t sig2n
```
2. Use the following command and your two tokens to begin the process.
```
docker run --rm -it portswigger/sig2n ey.... ey....
```
3. You will get a similar output formatted nicely and simplifying the following steps.

```
Found n with multiplier 1:
   Base64 encoded x509 key: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRURsSXQxdzFaNy8zcGZjNmcwSUw3KwpmRUwyd2U1bTRhRjd2cmJBVnVTWEZLWVBMMG1iLzFiRFhwYWtXME1oZEIwTEVYNlVYQVFKbXhPeE1xR1R4bTlSCkk1Y3plaVliTUx4TWVWOGk0LzdjSjh1dStsUk5wSFdETGF6QjR5NUFVcENudUdKZm51N0xJc0ROWDJrYWRqUXIKWTlPQzA1eFk1akdZeTlkdTdWSURXaTJqMkg1REFqaUJ3eDRDWFV4QjE1RVhob3YwZUlHWVF4Tngwa08rRDFtagoxcGV4dGRXRmxtcDVja081ZVNPNzJLL29BcXhZUlUwOXhUcDF6bk1McDY0Yk1ybW5tWDlHaStFa3NCWldXc1NRClNHcE8xS0VZcUN0M3hJS0NsVTVaYWswLy85Z2VLNFBUL3JoR012YXpFWnFMUTFoQTBVcWg1M0JFcklqU0Fha0MKUFFJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==
   Tampered JWT: eyJraWQiOiJiNmIzYzk4Mi05OTYzLTQ5ZjMtOGI0ZS0wOWZlNjY5YzVmMDkiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiAicG9ydHN3aWdnZXIiLCAiZXhwIjogMTc1MTc1NDc1NSwgInN1YiI6ICJ3aWVuZXIifQ.ewL_eCcqFJ3W828CkgMpgRLZprgrRCsFgo5FxEox1vY
   Base64 encoded pkcs1 key: LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1JSUJDZ0tDQVFFRGxJdDF3MVo3LzNwZmM2ZzBJTDcrZkVMMndlNW00YUY3dnJiQVZ1U1hGS1lQTDBtYi8xYkQKWHBha1cwTWhkQjBMRVg2VVhBUUpteE94TXFHVHhtOVJJNWN6ZWlZYk1MeE1lVjhpNC83Y0o4dXUrbFJOcEhXRApMYXpCNHk1QVVwQ251R0pmbnU3TElzRE5YMmthZGpRclk5T0MwNXhZNWpHWXk5ZHU3VklEV2kyajJINURBamlCCnd4NENYVXhCMTVFWGhvdjBlSUdZUXhOeDBrTytEMW1qMXBleHRkV0ZsbXA1Y2tPNWVTTzcySy9vQXF4WVJVMDkKeFRwMXpuTUxwNjRiTXJtbm1YOUdpK0Vrc0JaV1dzU1FTR3BPMUtFWXFDdDN4SUtDbFU1WmFrMC8vOWdlSzRQVAovcmhHTXZhekVacUxRMWhBMFVxaDUzQkVySWpTQWFrQ1BRSURBUUFCCi0tLS0tRU5EIFJTQSBQVUJMSUMgS0VZLS0tLS0K
   Tampered JWT: eyJraWQiOiJiNmIzYzk4Mi05OTYzLTQ5ZjMtOGI0ZS0wOWZlNjY5YzVmMDkiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiAicG9ydHN3aWdnZXIiLCAiZXhwIjogMTc1MTc1NDc1NSwgInN1YiI6ICJ3aWVuZXIifQ.GJTYtROC-9m8iC9ZM5fuU8V5XWQe2HPPMLWoNyrKL0U

Found n with multiplier 5:
   Base64 encoded x509 key: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUF0MDhYalhleVprdXNzTHM5b0NZeQo1YWIrSnNsSHhybmxqSXJ6UkpRZU4xUnBiOXVGbVhmQXJJU0hSWFBUZlo5b25SbFEzelFCNjlDOUNpQlF3VWwyCm9MZlhHRzRGY0NXbzVSTUcrbVlzQi9XSlpVUVBoMHF6MWU5WitqeHpRN2FIOGExR1V2eVBCdk5jUmtnNGZncHYKRS9jYUtsSjRMZ25yVy9maS9FT2FSVHhUK0JsQW1ndE5Kd1lBZVE5QVhsQTM1N1dYUzAwZWM5Q3dYVUMvbkt1SApLdXNqaXNSTjZ1SVlTZzJMZnFDL0sxWmhtaUo0RGR3L2pkaDk5aGNDVkx4cjF2SHVVZVpCVHkwSFZtcmVFaWRRCkRudXBYYm5SdXp2a3dPYm02cWxGRlVLbVpsNXNieHBkbVZnT0NqRlhBNFZQRFhnTTlxaUd4K05BNzA2UVpydG0KMlFJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==
   Tampered JWT: eyJraWQiOiJiNmIzYzk4Mi05OTYzLTQ5ZjMtOGI0ZS0wOWZlNjY5YzVmMDkiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiAicG9ydHN3aWdnZXIiLCAiZXhwIjogMTc1MTc1NDc1NSwgInN1YiI6ICJ3aWVuZXIifQ.cdJXx2tais2w1BzuwfTGbQdBN6KaWCwqc_FLzf2URR4
   Base64 encoded pkcs1 key: LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1JSUJDZ0tDQVFFQXQwOFhqWGV5Wmt1c3NMczlvQ1l5NWFiK0pzbEh4cm5saklyelJKUWVOMVJwYjl1Rm1YZkEKcklTSFJYUFRmWjlvblJsUTN6UUI2OUM5Q2lCUXdVbDJvTGZYR0c0RmNDV281Uk1HK21Zc0IvV0paVVFQaDBxegoxZTlaK2p4elE3YUg4YTFHVXZ5UEJ2TmNSa2c0ZmdwdkUvY2FLbEo0TGduclcvZmkvRU9hUlR4VCtCbEFtZ3ROCkp3WUFlUTlBWGxBMzU3V1hTMDBlYzlDd1hVQy9uS3VIS3VzamlzUk42dUlZU2cyTGZxQy9LMVpobWlKNERkdy8KamRoOTloY0NWTHhyMXZIdVVlWkJUeTBIVm1yZUVpZFFEbnVwWGJuUnV6dmt3T2JtNnFsRkZVS21abDVzYnhwZAptVmdPQ2pGWEE0VlBEWGdNOXFpR3grTkE3MDZRWnJ0bTJRSURBUUFCCi0tLS0tRU5EIFJTQSBQVUJMSUMgS0VZLS0tLS0K
   Tampered JWT: eyJraWQiOiJiNmIzYzk4Mi05OTYzLTQ5ZjMtOGI0ZS0wOWZlNjY5YzVmMDkiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiAicG9ydHN3aWdnZXIiLCAiZXhwIjogMTc1MTc1NDc1NSwgInN1YiI6ICJ3aWVuZXIifQ.260HYx49MSu--mfw8zP0EGLBhhJ7n92S5JbNwMr2-Pc
```
4. Next you want to grab the tampered tokens and see which one lets you authenticate with the user account.
5. After this, it's the same concept as the previous attack. Once verifying the token that works, copy the associated Base64 encoded key and use it as the secret for your symetric algorithim key.
6. Sign the token with the symmetric key and change the algorithm header.
![img-description](/assets/not_exposed.png)

## Conclusion

Secure impelementations of JWTs is necessary in order to prevent malicious actors from tampering with tokens and gain unauthorized access. Robust signature varification along with white-listing for certain parameters should be in place.

## Resources
https://portswigger.net/web-security/jwt

https://portswigger.net/web-security/jwt/algorithm-confusion


